---
title: "CALIDAD DE AIRE"
author:
  - María Paula Camargo Rincón
  - Laura Katherin Martinez Castiblanco
  - Yudy Vanessa Puerres Rosero
date: "2025-10-20"
output: pdf_document
---
```{r}
rm(list=ls())
```


# librerías
```{r}
#install.packages("readxl")
#install.packages("knitr")
#install.packages("forecast")
#install.packages("FinTS")
#install.packages("dplyr")
#install.packages("ggplot2")
#install.packages(lubridate")
#install.packages("zoo")
library(readxl) # Para leer el csv
library(knitr) # Para obtener la tabla en el pdf a partir de una tabla en r
library(forecast) # para el lambda de box-cox
library(tseries) # prueba de estacionariedad adf
library(FinTS)
library(dplyr) # para manejo de datos
library(ggplot2) # para gráficas
library(lubridate) # fechas
library(zoo) #imputación de datos faltantes
```

# Descripción de los datos:

## Base de datos
```{r}
aire <- read_excel("Datos_India.xlsx")
knitr::kable(head(aire,10),
             caption = "Primeros 10 datos",
             digits = 4)  # redondea a 4 decimales
```
```{r}
# Convert 'City' and 'AQI_Bucket' to factor variables
aire$City <- as.factor(aire$City)
aire$AQI_Bucket <- as.factor(aire$AQI_Bucket)

# Convert 'Date' to a date variable, specifying the format
aire$Date <- as.Date(aire$Date, format = "%d/%m/%Y")

summary(aire)

str(aire)
```
## Evaluación de base de datos
```{r}
# Group by Date and count the number of entries
daily_counts <- aire %>%
  group_by(Date) %>%
  summarise(count = n())

# Filter for dates with more than one entry
dates_with_duplicates <- daily_counts %>%
  filter(count > 1)


# Display the dates with duplicate entries
if (nrow(dates_with_duplicates) > 0) {
  cat("Días con mas de un valor de  PM2.5:\n")
  print(dates_with_duplicates)
} else {
  cat("No hay días con mas de un valor de PM2.5\n")
}
```
```{r}
aire[!complete.cases(aire), ]
# Usar interpolación lineal para rellenar valores faltantes en 'PM2.5'
# Podemos usar la función na.approx del paquete zoo para la interpolación lineal.
aire$`PM2.5` <- na.approx(aire$`PM2.5`)

# Verificar que no haya más valores faltantes en 'PM2.5'
missing_pm25_after_imputation <- sum(is.na(aire$`PM2.5`))
cat("Número de datos faltantes en 'PM2.5' después de la imputación:", missing_pm25_after_imputation, "\n")
```
```{r}
# Crear un gráfico de línea de la serie 'PM2.5' después de la imputación
ggplot(aire, aes(x = Date, y = `PM2.5`)) +
  geom_line() +
  labs(title = "Serie de PM2.5 después de la imputación",
       x = "Fecha",
       y = "PM2.5") +
  theme_minimal() + # Keep the minimal theme

cat("Estadísticas de resumen de 'PM2.5' después de la imputación:\n")
print(summary(aire))
```


```{r}
# Creación de la serie
start_date <- min(aire$Date)
end_date <- max(aire$Date)
PM2.5 <- ts(aire$`PM2.5`, start = c(year(start_date), month(start_date), day(start_date)), end = c(year(end_date), month(end_date), day(end_date)), frequency = 365)

# Gráfica
ts.plot(PM2.5, col = "darkcyan", lwd = 2,
        ylab = "PM2.5 promedio diario", xlab = "Tiempo",
        main = "Serie de tiempo de PM2.5 (diaria)")

```
Se ve estacionaria por lo menos en media, aunque parece tener distinta variación en algunos intervalos
```{r}
par(mfrow=c(1,2))
acf(PM2.5) # decaimiento lento indica que la serie no es estacionaria
pacf(PM2.5)
```

```{r}
adf_result <- adf.test(PM2.5, alternative = "stationary")
cat("Prueba ADF:\n Estadístico =", round(adf_result$statistic, 4),
    ", p-valor =", adf_result$p.value, "\n")
```
```{r}
# Estadísticas descriptivas
summary_stats <- aire %>%
  summarise(
    Media = mean(PM2.5, na.rm = TRUE),
    Mediana = median(PM2.5, na.rm = TRUE),
    Desv_Est = sd(PM2.5, na.rm = TRUE),
    Min = min(PM2.5, na.rm = TRUE),
    Max = max(PM2.5, na.rm = TRUE)
  )

kable(summary_stats, digits = 3, caption = "Estadísticas descriptivas de PM2.5 ")
```

La variación no es constante, se puede considerar una transformación logaritmica o de box cox
```{r}
lambda <- BoxCox.lambda(PM2.5)
lambda

```
Como el lambda obtenido fue cercano a 0, se aplicará la transformación de logaritmica.
```{r}
# Transformación logarítmica
l.PM2.5 <- log(PM2.5)
ts.plot(l.PM2.5, col = "darkblue",
        ylab = "log(PM2.5 promedio diario)",
        main = "Serie transformada logarítmicamente")

```

Parece seguir siendo estacionaria en media:

```{r}
adf.test(l.PM2.5,alternative = "stationary")
```

# Modelos

```{r}
par(mfrow=c(1,2))
acf(l.PM2.5)
pacf(l.PM2.5)
```
Pareciera que un MA(9) es adecuado, tal vez AR(9)
```{r}
ma9 <- arima(x = l.PM2.5,order = c(0,0,9))
ma9
ar9 <- arima(x = l.PM2.5,order = c(9,0,0))
ar9
arma9.9 <- arima(x = l.PM2.5,order = c(9,0,9))
arma9.9
```

```{r}
parametros <- c("Intercepto",
                paste0("ar", 1:9), 
                paste0("ma", 1:9),
                "logLik", "AIC")
resumen <- data.frame(
  "Parámetro" = parametros,
  
  # Modelo AR(9)
  "AR(9)" = c(coef(ar9)[10],coef(ar9)[-10], rep(NA, 9), ar9$loglik, ar9$aic),
  
  # Valor t (significancia) para AR(9)
  "t-valor AR(9)" = c((ar9$coef / sqrt(diag(ar9$var.coef)))[10],
                      (ar9$coef / sqrt(diag(ar9$var.coef)))[-10], 
                      rep(NA, 9), NA, NA),
  
  # Modelo MA(9)
  "MA(9)" = c(coef(ma9)[10],rep(NA, 9), coef(ma9)[-10], ma9$loglik, ma9$aic),
  
  # Valor t (significancia) para MA(9)
  "t-valor MA(9)" = c((ma9$coef / sqrt(diag(ma9$var.coef)))[10],
                      rep(NA, 9), 
                      (ma9$coef / sqrt(diag(ma9$var.coef)))[-10], NA, NA)
)
knitr::kable(resumen,
             caption = "Tabla de resumen de los modelos",
             digits = 3,
             row.names = F)
```


```{r}

```